//################# DNS-SYNC #################
//https://nvd.nist.gov/vuln/detail/CVE-2017-16100
//Type : Exponential
//Fix : Non-backtracking regex engine
//Attack String : 

import express from 'express';
import dnsSync from 'dns-sync';
import {exec} from 'child_process';
import functionTimeout from 'function-timeout';

const router_cve_2017_16100 = express.Router();

async function performNslookup(domain) {
    try {
        const response = await fetch(`https://dns.google/resolve?name=${domain}`);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const json = await response.json();
        const answer = json.Answer && json.Answer.find(record => record.type === 1); // Type 1 is for A records
        if (answer) {
            return answer.data;
        } else {
            throw new Error('IP address not found');
        }
    } catch (error) {
        console.error('DNS lookup error:', error);
        throw error;
    }
}

router_cve_2017_16100.get('/lookup', (req, res) => {
    const hostname = req.query.hostname;
    const ip = dnsSync.resolve(hostname);
    if (ip) {
        res.send(`Resolved`);
    } else {
        res.status(404).send(`Could not resolve hostname.`);
    }
});

router_cve_2017_16100.post('/index',(req, res) => {
    const input = req.body.input;

    const result = dnsSync.resolve(input);
  
    if (result) {
        res.send('CVE-2017-16100: Regex matched successfully');
    } else {
        res.send('CVE-2017-16100: Regex did not match');
    }
});

router_cve_2017_16100.post('/diff_regex_engine',(req, res) => {
    const input = req.body.input;
    const result = dnsSync.resolve(input,1);  
    if (result) {
        res.send('CVE-2017-16100: Regex matched successfully');
    } else {
        res.status(400).send('CVE-2017-16100: Regex did not match');
    }
});

router_cve_2017_16100.post('/alternate_logic', async (req, res) => {
    const domain = req.body.input;

    if (!domain) {
        return res.status(400).send('Domain query parameter is required');
    }

    try {
        const ip = await performNslookup(domain);
        res.send(`IP address: ${ip}`);
    } catch (error) {
        res.status(500).send(`Error: ${error.message}`);
    }
});

function regexMatch(input) {
    const result = dnsSync.resolve(input);
    return result;
}

const regexMatchWithTimeout = functionTimeout(regexMatch, {timeout:1000}); 

router_cve_2017_16100.post('/timeout', (req, res) => {
    const input = req.body.input;
    try {
        const result = regexMatchWithTimeout(input);
        console.log('Result:', result);
        res.send({ result });
    } catch (error) {
        console.error('Error:', error.message);
        res.status(500).send({ error: 'Regex operation timed out or failed' });
    }
});

const timeoutModified = functionTimeout(regexMatch, {timeout:500}); 

router_cve_2017_16100.post('/modified_timeout', (req, res) => {
    const input = req.body.input;
    try {
        const result = timeoutModified(input);
        console.log('Result:', result);
        res.send({ result });
    } catch (error) {
        console.error('Error:', error.message);
        res.status(500).send({ error: 'Regex operation timed out or failed' });
    }
});

router_cve_2017_16100.post('/repair', (req, res) => {
    const input = req.body.input;
    const regex = /^(?:(?:(((?:[ d]|[ghtw](?:(?:[ .eglw])*)[cdhmopu]))[ilow]))*)((?:[^ b-eghtw]|[bc](?:(?:[ .cdinp])*)[^ .cdimnp]))$/; 
    if (regex.test(input)) {
        res.send('CVE-2017-16100: Regex matched successfully');
    } else {
        res.status(400).send('CVE-2017-16100: Regex did not match');
    }
});



export default router_cve_2017_16100;